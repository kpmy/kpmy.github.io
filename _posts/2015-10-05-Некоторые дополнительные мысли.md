---
published: true
layout: post
---

* *Почему сначала класс объекта, а потом необязательный идентификатор (имя)?*
  * Потому что шаблон принципиально работает с объектом еще до его создания, то есть, на самом деле шаблон для разработчика и для шаблонизатора должен формировать новый объект из заданного класса. Зачастую, этого достаточно, а если недостаточно, то уже можно обращаться к конкретному объекту.
* *Как будет обеспечиваться модульность шаблонов?*
  * Скорее всего, модульность шаблонов будет обеспечиваться таким же образом, как и в `LOMO`, то есть, вложенных шаблонов не будет, один шаблон - одна импортируемая сущность. Что не исключает возможности группировки шаблонов в подсистемы чисто организационно, на уровне файловой системы и полного квалификатора имени. Так же возможно будут экспортированные константы и объекты внутри сущностей (например, стандартные аттрибуты html).
* *Шаблоны декларативные или императивные?*
  * Описание шаблона мультипарадигменное, тут и декларативная часть, и императивная часть и работа с контекстом, который каждый раз меняется под действием самого шаблона.
* *Процедуры и модульность внутри `LEAF`, импорт юнитов в `LOMO`?*
  * Так как менять языки не хочется, скорее всего импорт из любого модуля будет возможен на этапе выполнения шаблона. Допустим это будет выглядеть так:

        CORE.TEMPLATE(my-little-tree):
          CHESS:
            DO! IMPORT Strings

              PROCEDURE Invert
                VAR i+, o- STRING
              BEGIN
                o := i[\LEN i .. 0] (* range-нотации пока нет в LEAF *)
              END Invert

            VAR s STRING
            BEGIN
              Invert(o: "K F G", i -> s)
              THIS: move = s;
            END;
            CALC!
              VAR x INTEGER
            PROCESS
              2 -> x
              x ^ 2 -> THIS number;
            END;
          ;
        ;

* *Громоздко!*
  * императивный код -> декларативный код -> шаблонный код, чем дальше тем хуже. Но попробовать стоит. Конечно, для поддержки инструкций шаблонов внутри встраиваемых языков их компиляторы придётся доработать, но формально это останутся те же языки с полным набором фич. Заодно можно попробовать наконец-то сделать обобщенную кодовую базу для всех языков.
