---
published: false
---

## Изучая Lola

Поизучал описание языка [Lola](http://www.inf.ethz.ch/personal/wirth/Lola/index.html), в итоге понял, что MODULE это такая радиодеталь с ножками, вход/выход, внутренние преобразования по заданным функциям, вот это всё.
Подумал над применением в программировании акторов или агентов, ведь агент это та же радиодеталь, датчики как входы, манипуляторы, как выходы. На программном урове, это всё, конечно, укладывается в понятия направленного канала сообщений и сообщения. Сообщением в LEAF можно сделать любой тип данных, передавать можно значения, или даже указатели, если они будут защищены от записи.

Придумалось тут:
````
UNIT Fib
	VAR res+, n- INTEGER
	VAR f Fib
PROCESS
	f.n <- n - 1
	res <- IF n # 0 THEN n + f.res ELSE 1 END
END Fib

UNIT Fact
	VAR res+, n- INTEGER
	REG x INTEGER
INIT
	x <- 1
PROCESS
	res <- IF n = 0 THEN x END
	x <- IF n # 0 THEN x*n ELSE 1 END
	n <- IF n # 0 THEN n - 1 END
END Fact

UNIT Top
	REG x, y INTEGER
	VAR fi Fib
	VAR fa Fact
PROCESS
	fi.n <- 10
	x <- IF x = 0 THEN fi.res END
	fa.n <- 10
	y <- IF y = 0 THEN fa.res END
END Top
````

В целом, как и в Lola, есть только инструкция присваивания. Точнее даже не присваивания, а ожидания. Вся активность модулей определяется итерациями инструкций внутри секции PROCESS. Формально, это статичное описание состояния, а не итерации, но исполнять иначе не получится. По завершению первой итерации модуль `Top` ожидает от `Fib` и `Fact` сообщений из выходного канала `res`, так как условие `x = 0` истинно.
Наверное, так устроены все декларативные языки.
 
