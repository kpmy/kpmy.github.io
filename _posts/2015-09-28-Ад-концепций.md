---
layout: post
---

Что если всё это время понятие *жизнь программы* недооценивали? *Жизнь*, а точнее, *жизненный цикл* программы можно описать повторяющейся последовательностью конечных процессов. Обязательно конечных, в каком-то разумном временном отрезке.

Когда появляется программа? Скорее всего, программа появляется в голове у проектировщика/разработчика. Но так как этот момент не поддаётся контролю компьютера (пока), то предположим, что моментом появления программы является момент создания минимального запускаемого (о подробном смысле этого термина стоит поговорить отдельно) исходного кода. В контексте Оберона - программа рождается, когда появляется минимальный модуль.

Затем, после этапа написания некоторого программного кода, программа передается компилятору. Компилятор обеспечивает т.н. compile-time, *время компиляции*. В результате выполнения процесса компиляции мы получаем компилят (то есть непосредственный результат обработки нашего исходного кода). 

Во время компиляции наш исходный код влияет на работу компилятора по определенным законам, которые выражены в коде компилятора. В то же самое время, никто не мешает уже на этапе компиляции управлять действиями компилятора (точнее, исполнителя в целом) не опосредованно, через написание текста нашей программы, а непосредственно, через *написание кода общего назначения, который будет выполнен компилятором*, то есть такого кода, который хоть и относится к задуманной программе, но не переводится компилятором в компилят непосредственно. Так называемый [CTFE](https://en.wikipedia.org/wiki/Compile_time_function_execution), но в более общем смысле. 

Понятно, что нахождение в контексте процесса работы компилятора может накладывать некоторые ограничения на *код времени компиляции*, однако может и не накладывать. 

Здесь мы можем заметить, что выполнение любого процесса жизненного цикла предполагает наличие результата, в явном или неявном виде. 
