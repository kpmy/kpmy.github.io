---
published: true
layout: post
---

Довольно быстро выяснилось, что, так скажем, обобщить парсер невозможно. Есть возможность выделить в парсерах похожих языков некоторые одинаковые части, но на этом обобщение и закончится. Потому что даже разбор выражений зависит от определенной конкретной грамматики. Беглый поиск не дал информации о каком-то способе обобщения любых выражений (expressions) хотя бы арифметики. И это 2015-й год. Каждый лепит что-то своё, у кого `OR`, у кого `||`, у кого `or`, у кого `^`, у кого `**`, `=`, `->`, `:=`, и так далее, про целочисленное деление вообще молчу. Позорище вселенского масштаба. Никакой возможности обобщить и унифицировать.

Не зря Н. Вирт не стеснялся дублировать код компилятора от проекта к проекту, раз за разом, жестоко нарушая принцип DRY, чем очень злил вчерашних школьников, угоревших по всяким красивым принципам, манифестам, высерам Макконелла и так далее.

Ну ничего, даже в варианте с частичным обобщением уже нарисовался один важный паттерн потоковой обработки текста исходника. Его я и описал в соответствующем интерфейсе. Ещё из того, что я помню из разработки компиляторов, всегда было костыльно-проблематично описать результат работы компилятора.

У Вирта это был непосредственно генератор маш.кодов, минимальный объект с кучей полей, сразу видно, автор выделил минимум и его держался. У меня это превратилось в набор билдеров и холдеров, билдер содержит непосредственный результат разбора исходника и производит внутренние трансформации, холдер принимает на хранение результат работы билдера, часто это AST и вспомогательные индексы переменных, полей, параметров и модулей. Довольно странная структура, возможно, она тоже никак не обобщается.

В итоге получится инструментальный набор юного компиляторщика, не иначе. 
